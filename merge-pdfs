#!/usr/bin/env python3
import os
import argparse
import io
import sys
import re  # 新增：用于正则匹配
from pathlib import Path

# Third-party libraries
from pypdf import PdfWriter, PdfReader
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn, TimeRemainingColumn
from rich.panel import Panel

console = Console()

def register_chinese_font() -> str:
    """
    尝试注册一个兼容 ReportLab (TrueType 轮廓) 的中文字体。
    """
    font_name = "ChineseFont"
    
    candidate_paths = [
        Path("./NotoSansSC-Regular.ttf"),
        Path("/usr/share/fonts/truetype/wqy/wqy-microhei.ttc"),
        Path("/usr/share/fonts/truetype/wqy/wqy-zenhei.ttc"),
        Path("/usr/share/fonts/truetype/noto/NotoSansCJK-Regular.ttc"),
        Path("/usr/share/fonts/truetype/noto/NotoSansSC-Regular.ttf"),
        Path(os.path.expanduser("~/.local/share/fonts/NotoSansSC-Regular.ttf")),
    ]

    for path in candidate_paths:
        if path.exists():
            try:
                if path.suffix == ".ttc":
                    pdfmetrics.registerFont(TTFont(font_name, path, subfontIndex=0))
                else:
                    pdfmetrics.registerFont(TTFont(font_name, path))
                
                console.print(f"[green]✓ Loaded Font:[/green] {path}")
                return font_name
            except Exception as e:
                console.print(f"[dim yellow]! Skipped incompatible font {path.name}: {e}[/dim yellow]")
                continue
    
    console.print("[bold red]! No compatible Chinese font found.[/bold red]")
    console.print("[yellow]Tip: sudo apt install fonts-wqy-microhei[/yellow]")
    return "Helvetica"

CURRENT_FONT = register_chinese_font()

def create_title_page(text: str) -> PdfReader:
    """
    创建封面页：大号粗体，上下横线。
    使用“几何偏移”法模拟粗体。
    """
    packet = io.BytesIO()
    can = canvas.Canvas(packet, pagesize=letter)
    width, height = letter
    
    # --- 样式配置 ---
    font_size = 24
    line_width = 2
    line_margin = 80
    
    can.setFont(CURRENT_FONT, font_size)
    
    try:
        text_width = can.stringWidth(text, CURRENT_FONT, font_size)
    except:
        text_width = len(text) * font_size
        
    x_text = (width - text_width) / 2
    y_text = height / 2
    
    # 绘制伪粗体 (4次偏移)
    offset = 0.5 
    can.drawString(x_text, y_text, text)
    can.drawString(x_text + offset, y_text, text)
    can.drawString(x_text, y_text + offset, text)
    can.drawString(x_text + offset, y_text + offset, text)
    
    # 绘制上下横线
    can.setLineWidth(line_width)
    line_top_y = y_text + font_size + 10
    line_bottom_y = y_text - 15
    can.line(line_margin, line_top_y, width - line_margin, line_top_y)
    can.line(line_margin, line_bottom_y, width - line_margin, line_bottom_y)
    
    can.showPage()
    can.save()
    
    packet.seek(0)
    return PdfReader(packet)

def merge_pdfs(source_dir: str, output_file: str):
    writer = PdfWriter()
    root_path = Path(source_dir)
    output_path = Path(output_file)
    
    if not root_path.exists():
        console.print(f"[bold red]Error:[/bold red] Directory '{source_dir}' does not exist.")
        sys.exit(1)

    # --- 1. 扫描与过滤 ---
    with console.status("[bold green]Scanning and Filtering...[/bold green]"):
        # 正则表达式：匹配 YYYY-MM-DD 开头
        # ^ 表示开头, \d{4} 表示4位数字, \d{2} 表示2位数字
        date_pattern = re.compile(r"^\d{4}-\d{2}-\d{2}")
        
        all_pdfs = [f for f in root_path.rglob("*") if f.suffix.lower() == '.pdf']
        
        valid_files = []
        skipped_count = 0
        
        for f in all_pdfs:
            # 排除输出文件自己
            if f.resolve() == output_path.resolve():
                continue
                
            # 核心过滤逻辑：只有文件名符合日期格式才加入
            if date_pattern.match(f.name):
                valid_files.append(f)
            else:
                skipped_count += 1

        # 排序
        sorted_files = sorted(valid_files, key=lambda f: f.name)

    # --- 2. 汇报扫描结果 ---
    if not sorted_files:
        console.print("[yellow]No valid date-formatted PDF files found (YYYY-MM-DD...).[/yellow]")
        if skipped_count > 0:
            console.print(f"[dim]Skipped {skipped_count} files that didn't match the date pattern.[/dim]")
        return

    summary_panel = Panel(
        f"Valid Date Files: [bold cyan]{len(sorted_files)}[/bold cyan]\n"
        f"Skipped Files:    [bold yellow]{skipped_count}[/bold yellow]\n"
        f"Source Dir:       [bold]{source_dir}[/bold]", 
        title="Scan Complete"
    )
    console.print(summary_panel)

    # --- 3. 处理合并 ---
    success_count = 0
    
    progress_columns = [
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        BarColumn(),
        TaskProgressColumn(),
        TimeRemainingColumn(),
    ]

    with Progress(*progress_columns, console=console) as progress:
        task = progress.add_task("[cyan]Merging PDFs...", total=len(sorted_files))
        
        for pdf_file in sorted_files:
            progress.update(task, description=f"[cyan]Processing: {pdf_file.name}[/cyan]")
            
            try:
                # 添加封面
                title_page = create_title_page(pdf_file.name)
                writer.add_page(title_page.pages[0])

                # 添加内容
                reader = PdfReader(pdf_file)
                for page in reader.pages:
                    writer.add_page(page)
                
                success_count += 1
                
            except Exception as e:
                console.print(f"[red]Error processing {pdf_file.name}: {e}[/red]")
            
            progress.advance(task)

    # --- 4. 写入文件 ---
    console.print(f"[dim]Writing output to {output_file}...[/dim]")
    try:
        with open(output_file, "wb") as out_f:
            writer.write(out_f)
        
        console.print(Panel(
            f"[bold green]Success![/bold green]\n"
            f"Merged {success_count} files.\n"
            f"Output: [underline]{output_file}[/underline]",
            border_style="green"
        ))
    except Exception as e:
        console.print(f"[bold red]Failed to write output file:[/bold red] {e}")

def main():
    parser = argparse.ArgumentParser(description="Recursively merge date-prefixed PDFs (YYYY-MM-DD).")
    parser.add_argument("directory", nargs="?", default=".", help="Root directory")
    parser.add_argument("-o", "--output", default="merged_output.pdf", help="Output filename")
    args = parser.parse_args()
    merge_pdfs(args.directory, args.output)

if __name__ == "__main__":
    main()
